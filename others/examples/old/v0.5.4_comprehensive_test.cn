using lib <io>;
using ns std;

// CodeNothing v0.5.4 综合功能测试
// 展示函数指针数组和Lambda闭包的完整功能

// 基础数学函数
fn add(a : int, b : int) : int {
    return a + b;
};

fn subtract(a : int, b : int) : int {
    return a - b;
};

fn multiply(a : int, b : int) : int {
    return a * b;
};

fn divide(a : int, b : int) : int {
    if (b != 0) {
        return a / b;
    } else {
        return 0;
    };
};

fn main() : int {
    std::println("=== CodeNothing v0.5.4 综合功能测试 ===");
    std::println("");
    
    // 测试1：函数指针数组基础功能
    testFunctionPointerArrayBasics();
    
    // 测试2：Lambda函数指针数组
    testLambdaFunctionPointerArray();
    
    // 测试3：Lambda闭包基础功能
    testLambdaClosureBasics();
    
    // 测试4：多变量闭包
    testMultiVariableClosure();
    
    // 测试5：复合表达式和高级用法
    testAdvancedUsage();
    
    std::println("");
    std::println("=== 🎉 CodeNothing v0.5.4 所有功能测试完成！ ===");
    return 0;
};

fn testFunctionPointerArrayBasics() : void {
    std::println("1. 函数指针数组基础功能测试");
    std::println("===========================");
    
    // 函数指针数组声明和初始化
    operations : []*fn(int, int) : int = [add, subtract, multiply, divide];
    
    // 数组索引访问
    firstOp : *fn(int, int) : int = operations[0];
    result1 : int = firstOp(20, 8);
    std::println("operations[0](20, 8) = " + result1);
    
    // 直接调用语法
    result2 : int = operations[1](20, 8);
    std::println("operations[1](20, 8) = " + result2);
    
    result3 : int = operations[2](20, 8);
    std::println("operations[2](20, 8) = " + result3);
    
    result4 : int = operations[3](20, 8);
    std::println("operations[3](20, 8) = " + result4);
    
    std::println("");
};

fn testLambdaFunctionPointerArray() : void {
    std::println("2. Lambda函数指针数组测试");
    std::println("=========================");
    
    // 纯Lambda函数指针数组
    lambdas : []*fn(int, int) : int = [
        ((a, b) => a + b),           // 加法
        ((a, b) => a - b),           // 减法
        ((a, b) => a * b),           // 乘法
        ((a, b) => a * a + b * b)    // 平方和
    ];
    
    // 直接调用Lambda数组元素
    result1 : int = lambdas[0](6, 4);
    std::println("lambdas[0](6, 4) = " + result1 + " (加法)");
    
    result2 : int = lambdas[1](6, 4);
    std::println("lambdas[1](6, 4) = " + result2 + " (减法)");
    
    result3 : int = lambdas[2](6, 4);
    std::println("lambdas[2](6, 4) = " + result3 + " (乘法)");
    
    result4 : int = lambdas[3](6, 4);
    std::println("lambdas[3](6, 4) = " + result4 + " (平方和: 6² + 4² = 52)");
    
    // 混合数组：函数和Lambda
    mixed : []*fn(int, int) : int = [add, ((a, b) => a * b), subtract];
    result5 : int = mixed[1](7, 3);
    std::println("mixed[1](7, 3) = " + result5 + " (Lambda乘法)");
    
    std::println("");
};

fn testLambdaClosureBasics() : void {
    std::println("3. Lambda闭包基础功能测试");
    std::println("=========================");
    
    // 外部变量
    multiplier : int = 5;
    
    // Lambda捕获外部变量
    multiplyByFactor : *fn(int) : int = (x => x * multiplier);

    result1 : int = multiplyByFactor(8);
    std::println("multiplyByFactor(8) = " + result1 + " (8 * 5 = 40)");

    result2 : int = multiplyByFactor(12);
    std::println("multiplyByFactor(12) = " + result2 + " (12 * 5 = 60)");
    
    // 字符串闭包测试暂时跳过（需要字符串拼接支持）
    
    std::println("");
};

fn testMultiVariableClosure() : void {
    std::println("4. 多变量闭包测试");
    std::println("=================");
    
    // 多个外部变量
    base : int = 10;
    factor : int = 3;
    offset : int = 5;
    
    // Lambda捕获多个外部变量
    complexCalc : *fn(int) : int = (x => x * factor + base + offset);
    
    result1 : int = complexCalc(4);
    std::println("complexCalc(4) = " + result1 + " (4 * 3 + 10 + 5 = 27)");
    
    result2 : int = complexCalc(7);
    std::println("complexCalc(7) = " + result2 + " (7 * 3 + 10 + 5 = 36)");
    
    // 闭包数组
    closures : []*fn(int) : int = [
        (x => x + base),           // 加基数
        (x => x * factor),         // 乘因子
        (x => x + offset)          // 加偏移
    ];
    
    result3 : int = closures[0](15);
    std::println("closures[0](15) = " + result3 + " (15 + 10 = 25)");
    
    result4 : int = closures[1](15);
    std::println("closures[1](15) = " + result4 + " (15 * 3 = 45)");
    
    result5 : int = closures[2](15);
    std::println("closures[2](15) = " + result5 + " (15 + 5 = 20)");
    
    std::println("");
};

fn testAdvancedUsage() : void {
    std::println("5. 复合表达式和高级用法测试");
    std::println("===========================");
    
    // 高级用法：函数指针数组 + 闭包
    threshold : int = 50;
    
    // 创建带闭包的函数指针数组
    processors : []*fn(int) : int = [
        (x => x * 2),                    // 双倍
        (x => x + threshold),            // 加阈值
        (x => x * x),                    // 平方
        (x => x + 1)                         // 加一
    ];
    
    testValue : int = 8;
    
    result1 : int = processors[0](testValue);
    std::println("processors[0](" + testValue + ") = " + result1 + " (双倍)");
    
    result2 : int = processors[1](testValue);
    std::println("processors[1](" + testValue + ") = " + result2 + " (加阈值)");
    
    result3 : int = processors[2](testValue);
    std::println("processors[2](" + testValue + ") = " + result3 + " (平方)");
    
    // 函数指针数组的方法调用
    std::println("函数指针数组信息:");
    firstProcessor : *fn(int) : int = processors[0];
    std::println("  第一个元素类型: " + firstProcessor.getReturnType());
    std::println("  第一个元素是Lambda: " + firstProcessor.isLambda());
    
    std::println("");
};

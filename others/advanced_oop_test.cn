// CodeNothing é«˜çº§OOPç‰¹æ€§æµ‹è¯•
// æµ‹è¯•æŠ½è±¡ç±»ã€æ¥å£ã€å‹å…ƒç±»ç­‰é«˜çº§ç‰¹æ€§

using lib <io>;
using ns std;

// æŠ½è±¡åŸºç±» - è½¦è¾†
abstract class Vehicle {
    protected brand : string;
    protected model : string;
    protected year : int;
    private vin : string;
    
    constructor(brand : string, model : string, year : int) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        this.vin = this.generate_vin();
        std::println("åˆ›å»ºè½¦è¾†: " + brand + " " + model + " (" + year + ")");
    };
    
    // æŠ½è±¡æ–¹æ³• - å¿…é¡»è¢«å­ç±»å®ç°
    abstract fn start_engine() : string;
    abstract fn get_fuel_type() : string;
    
    // è™šæ–¹æ³• - å¯ä»¥è¢«é‡å†™
    virtual fn get_max_speed() : int {
        return 120; // é»˜è®¤æœ€å¤§é€Ÿåº¦
    };
    
    // æ™®é€šæ–¹æ³•
    fn get_vehicle_info() : string {
        return this.year + " " + this.brand + " " + this.model;
    };
    
    // å—ä¿æŠ¤æ–¹æ³• - åªèƒ½è¢«å­ç±»è®¿é—®
    protected fn get_vin() : string {
        return this.vin;
    };
    
    // ç§æœ‰æ–¹æ³•
    private fn generate_vin() : string {
        return "VIN" + this.year + this.brand.substring(0, 2);
    };
    
    // é™æ€æ–¹æ³•
    static fn get_vehicle_regulations() : string {
        return "éµå®ˆäº¤é€šæ³•è§„";
    };
};

// æ¥å£ - ç”µåŠ¨è½¦ç‰¹æ€§
interface Electric {
    fn charge_battery() : string;
    fn get_battery_level() : int;
    fn get_range() : int;
};

// æ¥å£ - è‡ªåŠ¨é©¾é©¶
interface Autonomous {
    fn enable_autopilot() : string;
    fn disable_autopilot() : string;
    fn is_autopilot_active() : bool;
};

// å…·ä½“ç±» - æ±½æ²¹è½¦
class GasolineCar extends Vehicle {
    private fuel_capacity : float;
    private current_fuel : float;

    constructor(brand : string, model : string, year : int, capacity : float) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        this.fuel_capacity = capacity;
        this.current_fuel = capacity; // æ»¡æ²¹çŠ¶æ€
        std::println("åˆ›å»ºæ±½æ²¹è½¦ï¼Œæ²¹ç®±å®¹é‡: " + capacity + "L");
    };
    
    // å®ç°æŠ½è±¡æ–¹æ³•
    override fn start_engine() : string {
        if (this.current_fuel > 0.0) {
            return "æ±½æ²¹å‘åŠ¨æœºå¯åŠ¨: " + this.get_vehicle_info();
        } else {
            return "ç‡ƒæ²¹ä¸è¶³ï¼Œæ— æ³•å¯åŠ¨";
        };
    };
    
    override fn get_fuel_type() : string {
        return "æ±½æ²¹";
    };
    
    // é‡å†™è™šæ–¹æ³•
    override fn get_max_speed() : int {
        return 180;
    };
    
    // æ±½æ²¹è½¦ç‰¹æœ‰æ–¹æ³•
    fn refuel(amount : float) : string {
        old_fuel : float = this.current_fuel;
        this.current_fuel = this.current_fuel + amount;
        if (this.current_fuel > this.fuel_capacity) {
            this.current_fuel = this.fuel_capacity;
        };
        return "åŠ æ²¹: " + old_fuel + "L -> " + this.current_fuel + "L";
    };
    
    fn get_fuel_level() : float {
        return this.current_fuel;
    };
};

// å…·ä½“ç±» - ç”µåŠ¨è½¦ï¼ˆå®ç°å¤šä¸ªæ¥å£ï¼‰
class ElectricCar extends Vehicle implements Electric, Autonomous {
    private battery_capacity : int;
    private current_battery : int;
    private autopilot_enabled : bool;

    constructor(brand : string, model : string, year : int, battery : int) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        this.battery_capacity = battery;
        this.current_battery = battery; // æ»¡ç”µçŠ¶æ€
        this.autopilot_enabled = false;
        std::println("åˆ›å»ºç”µåŠ¨è½¦ï¼Œç”µæ± å®¹é‡: " + battery + "kWh");
    };
    
    // å®ç°æŠ½è±¡æ–¹æ³•
    override fn start_engine() : string {
        if (this.current_battery > 0) {
            return "ç”µåŠ¨æœºå¯åŠ¨: " + this.get_vehicle_info();
        } else {
            return "ç”µæ± ç”µé‡ä¸è¶³ï¼Œæ— æ³•å¯åŠ¨";
        };
    };
    
    override fn get_fuel_type() : string {
        return "ç”µåŠ›";
    };
    
    // é‡å†™è™šæ–¹æ³•
    override fn get_max_speed() : int {
        return 200;
    };
    
    // å®ç°Electricæ¥å£
    fn charge_battery() : string {
        this.current_battery = this.battery_capacity;
        return "ç”µæ± å……ç”µå®Œæˆ: " + this.current_battery + "kWh";
    };
    
    fn get_battery_level() : int {
        return this.current_battery;
    };
    
    fn get_range() : int {
        return this.current_battery * 5; // å‡è®¾æ¯kWhå¯è¡Œé©¶5km
    };
    
    // å®ç°Autonomousæ¥å£
    fn enable_autopilot() : string {
        this.autopilot_enabled = true;
        return "è‡ªåŠ¨é©¾é©¶å·²å¯ç”¨";
    };
    
    fn disable_autopilot() : string {
        this.autopilot_enabled = false;
        return "è‡ªåŠ¨é©¾é©¶å·²å…³é—­";
    };
    
    fn is_autopilot_active() : bool {
        return this.autopilot_enabled;
    };
    
    // ç”µåŠ¨è½¦ç‰¹æœ‰æ–¹æ³•
    fn use_battery(amount : int) : string {
        old_battery : int = this.current_battery;
        this.current_battery = this.current_battery - amount;
        if (this.current_battery < 0) {
            this.current_battery = 0;
        };
        return "ç”µæ± ä½¿ç”¨: " + old_battery + "kWh -> " + this.current_battery + "kWh";
    };
};

// æ··åˆåŠ¨åŠ›è½¦ - å¤šé‡ç»§æ‰¿ç¤ºä¾‹
class HybridCar extends Vehicle implements Electric {
    private fuel_capacity : float;
    private current_fuel : float;
    private battery_capacity : int;
    private current_battery : int;
    private is_electric_mode : bool;

    constructor(brand : string, model : string, year : int, fuel_cap : float, battery_cap : int) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        this.fuel_capacity = fuel_cap;
        this.current_fuel = fuel_cap;
        this.battery_capacity = battery_cap;
        this.current_battery = battery_cap;
        this.is_electric_mode = true; // é»˜è®¤ç”µåŠ¨æ¨¡å¼
        std::println("åˆ›å»ºæ··åˆåŠ¨åŠ›è½¦ï¼Œæ²¹ç®±: " + fuel_cap + "L, ç”µæ± : " + battery_cap + "kWh");
    };
    
    // å®ç°æŠ½è±¡æ–¹æ³•
    override fn start_engine() : string {
        if (this.is_electric_mode && this.current_battery > 0) {
            return "ç”µåŠ¨æ¨¡å¼å¯åŠ¨: " + this.get_vehicle_info();
        } else if (!this.is_electric_mode && this.current_fuel > 0.0) {
            return "æ±½æ²¹æ¨¡å¼å¯åŠ¨: " + this.get_vehicle_info();
        } else {
            return "ç‡ƒæ–™å’Œç”µåŠ›éƒ½ä¸è¶³ï¼Œæ— æ³•å¯åŠ¨";
        };
    };
    
    override fn get_fuel_type() : string {
        if (this.is_electric_mode) {
            return "ç”µåŠ›";
        } else {
            return "æ±½æ²¹";
        };
    };
    
    // å®ç°Electricæ¥å£
    fn charge_battery() : string {
        this.current_battery = this.battery_capacity;
        return "æ··åŠ¨è½¦ç”µæ± å……ç”µå®Œæˆ: " + this.current_battery + "kWh";
    };
    
    fn get_battery_level() : int {
        return this.current_battery;
    };
    
    fn get_range() : int {
        electric_range : int = this.current_battery * 3; // ç”µåŠ¨ç»­èˆª
        fuel_range : int = this.current_fuel * 15; // æ±½æ²¹ç»­èˆªï¼ˆå‡è®¾æ¯å‡15kmï¼‰
        return electric_range + fuel_range;
    };
    
    // æ··åŠ¨è½¦ç‰¹æœ‰æ–¹æ³•
    fn switch_to_electric() : string {
        this.is_electric_mode = true;
        return "åˆ‡æ¢åˆ°ç”µåŠ¨æ¨¡å¼";
    };
    
    fn switch_to_gasoline() : string {
        this.is_electric_mode = false;
        return "åˆ‡æ¢åˆ°æ±½æ²¹æ¨¡å¼";
    };
    
    fn get_current_mode() : string {
        if (this.is_electric_mode) {
            return "ç”µåŠ¨æ¨¡å¼";
        } else {
            return "æ±½æ²¹æ¨¡å¼";
        };
    };
};

// è½¦é˜Ÿç®¡ç†ç±»
class Fleet {
    private vehicles : []Vehicle;
    private fleet_name : string;
    
    constructor(name : string) {
        this.fleet_name = name;
        this.vehicles = [];
        std::println("åˆ›å»ºè½¦é˜Ÿ: " + name);
    };
    
    fn add_vehicle(vehicle : Vehicle) : void {
        this.vehicles.push(vehicle);
        std::println("è½¦é˜Ÿæ·»åŠ è½¦è¾†: " + vehicle.get_vehicle_info());
        return;
    };
    
    fn start_all_vehicles() : void {
        std::println("=== å¯åŠ¨æ‰€æœ‰è½¦è¾† ===");
        foreach (vehicle in this.vehicles) {
            std::println(vehicle.start_engine());
        };
        return;
    };
    
    fn get_fleet_info() : string {
        return "è½¦é˜Ÿ: " + this.fleet_name + ", è½¦è¾†æ•°é‡: " + this.vehicles.length();
    };
};

// ä¸»å‡½æ•°
fn main() : int {
    std::println("ğŸš— CodeNothing é«˜çº§OOPç‰¹æ€§æµ‹è¯•");
    std::println("=====================================");
    
    // 1. åˆ›å»ºä¸åŒç±»å‹çš„è½¦è¾†
    std::println("1. åˆ›å»ºè½¦è¾†å®ä¾‹");
    gas_car : GasolineCar = new GasolineCar("ä¸°ç”°", "å¡ç½—æ‹‰", 2023, 50.0);
    electric_car : ElectricCar = new ElectricCar("ç‰¹æ–¯æ‹‰", "Model 3", 2023, 75);
    hybrid_car : HybridCar = new HybridCar("ä¸°ç”°", "æ™®é”æ–¯", 2023, 45.0, 30);
    std::println("");
    
    // 2. æµ‹è¯•æŠ½è±¡æ–¹æ³•å®ç°
    std::println("2. æŠ½è±¡æ–¹æ³•æµ‹è¯•");
    std::println(gas_car.start_engine());
    std::println(electric_car.start_engine());
    std::println(hybrid_car.start_engine());
    std::println("");
    
    // 3. æµ‹è¯•æ¥å£å®ç°
    std::println("3. æ¥å£æµ‹è¯•");
    std::println(electric_car.charge_battery());
    std::println("ç”µåŠ¨è½¦ç”µæ± ç”µé‡: " + electric_car.get_battery_level());
    std::println("ç”µåŠ¨è½¦ç»­èˆª: " + electric_car.get_range() + "km");
    
    std::println(electric_car.enable_autopilot());
    std::println("è‡ªåŠ¨é©¾é©¶çŠ¶æ€: " + electric_car.is_autopilot_active());
    std::println("");
    
    // 4. æµ‹è¯•å¤šé‡ç»§æ‰¿
    std::println("4. æ··åˆåŠ¨åŠ›è½¦æµ‹è¯•");
    std::println("å½“å‰æ¨¡å¼: " + hybrid_car.get_current_mode());
    std::println(hybrid_car.switch_to_gasoline());
    std::println("åˆ‡æ¢åæ¨¡å¼: " + hybrid_car.get_current_mode());
    std::println("æ··åŠ¨è½¦ç»­èˆª: " + hybrid_car.get_range() + "km");
    std::println("");
    
    // 5. è½¦é˜Ÿç®¡ç†æµ‹è¯•
    std::println("5. è½¦é˜Ÿç®¡ç†æµ‹è¯•");
    fleet : Fleet = new Fleet("æµ‹è¯•è½¦é˜Ÿ");
    fleet.add_vehicle(gas_car);
    fleet.add_vehicle(electric_car);
    fleet.add_vehicle(hybrid_car);
    
    std::println(fleet.get_fleet_info());
    fleet.start_all_vehicles();
    std::println("");
    
    // 6. é™æ€æ–¹æ³•æµ‹è¯•
    std::println("6. é™æ€æ–¹æ³•æµ‹è¯•");
    regulations : string = Vehicle::get_vehicle_regulations();
    std::println("è½¦è¾†æ³•è§„: " + regulations);
    std::println("");
    
    std::println("ğŸ‰ é«˜çº§OOPæµ‹è¯•å®Œæˆ!");
    std::println("=====================================");
    
    return 0;
};

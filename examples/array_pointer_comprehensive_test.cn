using lib <io>;
using ns std;

// CodeNothing 数组指针和指针数组综合测试
// 测试数组指针(*[size]Type)和指针数组([size]*Type)的完整语法

fn main() : int {
    std::println("=== CodeNothing 数组指针和指针数组综合测试 ===");
    std::println("");
    
    // 测试1：数组指针基础操作
    testArrayPointerBasics();
    
    // 测试2：指针数组基础操作
    testPointerArrayBasics();
    
    // 测试3：数组指针的索引访问
    testArrayPointerIndexing();
    
    // 测试4：指针数组的索引访问
    testPointerArrayIndexing();
    
    // 测试5：混合操作和边界检查
    testMixedOperationsAndBounds();
    
    std::println("");
    std::println("=== 数组指针和指针数组综合测试完成 ===");
    return 0;
};

fn testArrayPointerBasics() : void {
    std::println("1. 数组指针基础操作测试");
    std::println("========================");
    
    // 创建数组数据（模拟固定大小数组）
    arr1 : int = 10;
    arr2 : int = 20;
    arr3 : int = 30;
    arr4 : int = 40;
    arr5 : int = 50;
    
    // 创建数组指针（指向数组的第一个元素）
    arrayPtr : *int = &arr1;
    
    std::println("数组数据: [10, 20, 30, 40, 50]");
    std::println("数组指针: " + arrayPtr + " -> " + *arrayPtr);
    
    // 测试数组指针的基本属性
    std::println("数组指针属性:");
    std::println("  地址: " + arrayPtr.getAddress());
    std::println("  级别: " + arrayPtr.getLevel());
    std::println("  是否为空: " + arrayPtr.isNull());
    
    // 测试数组指针的算术运算
    ptr1 : *int = arrayPtr + 1;  // 指向第二个元素
    ptr2 : *int = arrayPtr + 2;  // 指向第三个元素
    ptr3 : *int = arrayPtr + 3;  // 指向第四个元素
    ptr4 : *int = arrayPtr + 4;  // 指向第五个元素
    
    std::println("数组指针算术:");
    std::println("  arrayPtr + 0: " + arrayPtr + " -> " + *arrayPtr);
    std::println("  arrayPtr + 1: " + ptr1 + " -> " + *ptr1);
    std::println("  arrayPtr + 2: " + ptr2 + " -> " + *ptr2);
    std::println("  arrayPtr + 3: " + ptr3 + " -> " + *ptr3);
    std::println("  arrayPtr + 4: " + ptr4 + " -> " + *ptr4);
    
    // 验证数组指针的正确性
    if (*arrayPtr == 10 && *ptr1 == 20 && *ptr2 == 30) {
        std::println("✓ 数组指针基础操作正确");
    } else {
        std::println("✗ 数组指针基础操作错误");
    };
    
    std::println("");
};

fn testPointerArrayBasics() : void {
    std::println("2. 指针数组基础操作测试");
    std::println("========================");
    
    // 创建多个变量
    val1 : int = 100;
    val2 : int = 200;
    val3 : int = 300;
    val4 : int = 400;
    val5 : int = 500;
    
    // 创建指向这些变量的指针
    ptr1 : *int = &val1;
    ptr2 : *int = &val2;
    ptr3 : *int = &val3;
    ptr4 : *int = &val4;
    ptr5 : *int = &val5;
    
    std::println("变量数据:");
    std::println("  val1: " + val1 + " (地址: " + ptr1 + ")");
    std::println("  val2: " + val2 + " (地址: " + ptr2 + ")");
    std::println("  val3: " + val3 + " (地址: " + ptr3 + ")");
    std::println("  val4: " + val4 + " (地址: " + ptr4 + ")");
    std::println("  val5: " + val5 + " (地址: " + ptr5 + ")");
    
    // 模拟指针数组（由于语法限制，使用单独的指针变量）
    std::println("指针数组模拟:");
    std::println("  ptrArray[0]: " + ptr1 + " -> " + *ptr1);
    std::println("  ptrArray[1]: " + ptr2 + " -> " + *ptr2);
    std::println("  ptrArray[2]: " + ptr3 + " -> " + *ptr3);
    std::println("  ptrArray[3]: " + ptr4 + " -> " + *ptr4);
    std::println("  ptrArray[4]: " + ptr5 + " -> " + *ptr5);
    
    // 测试指针数组的遍历
    std::println("指针数组遍历:");
    processPointerArrayElement(ptr1, 0);
    processPointerArrayElement(ptr2, 1);
    processPointerArrayElement(ptr3, 2);
    processPointerArrayElement(ptr4, 3);
    processPointerArrayElement(ptr5, 4);
    
    std::println("✓ 指针数组基础操作正确");
    std::println("");
};

fn testArrayPointerIndexing() : void {
    std::println("3. 数组指针索引访问测试");
    std::println("========================");
    
    // 创建连续的内存数据（模拟数组）
    data1 : int = 11;
    data2 : int = 22;
    data3 : int = 33;
    data4 : int = 44;
    data5 : int = 55;
    
    // 数组指针
    dataPtr : *int = &data1;
    
    std::println("数组数据: [11, 22, 33, 44, 55]");
    std::println("数组指针: " + dataPtr);
    
    // 测试索引访问（通过指针算术模拟）
    std::println("索引访问测试:");
    
    // 模拟 dataPtr[0], dataPtr[1], 等
    element0 : int = *dataPtr;           // dataPtr[0]
    element1 : int = *(dataPtr + 1);     // dataPtr[1]
    element2 : int = *(dataPtr + 2);     // dataPtr[2]
    element3 : int = *(dataPtr + 3);     // dataPtr[3]
    element4 : int = *(dataPtr + 4);     // dataPtr[4]
    
    std::println("  dataPtr[0] = " + element0);
    std::println("  dataPtr[1] = " + element1);
    std::println("  dataPtr[2] = " + element2);
    std::println("  dataPtr[3] = " + element3);
    std::println("  dataPtr[4] = " + element4);
    
    // 验证索引访问的正确性
    if (element0 == 11 && element1 == 22 && element2 == 33) {
        std::println("✓ 数组指针索引访问正确");
    } else {
        std::println("✗ 数组指针索引访问错误");
    };
    
    // 测试边界检查（模拟）
    std::println("边界检查测试:");
    safeArrayAccess(dataPtr, 0, 5);  // 有效索引
    safeArrayAccess(dataPtr, 2, 5);  // 有效索引
    safeArrayAccess(dataPtr, 4, 5);  // 边界索引
    safeArrayAccess(dataPtr, 5, 5);  // 超出边界
    
    std::println("");
};

fn testPointerArrayIndexing() : void {
    std::println("4. 指针数组索引访问测试");
    std::println("========================");
    
    // 创建目标变量
    target1 : int = 111;
    target2 : int = 222;
    target3 : int = 333;
    
    // 创建指针数组（模拟）
    ptrArray1 : *int = &target1;
    ptrArray2 : *int = &target2;
    ptrArray3 : *int = &target3;
    
    std::println("目标变量:");
    std::println("  target1: " + target1);
    std::println("  target2: " + target2);
    std::println("  target3: " + target3);
    
    std::println("指针数组:");
    std::println("  ptrArray[0]: " + ptrArray1);
    std::println("  ptrArray[1]: " + ptrArray2);
    std::println("  ptrArray[2]: " + ptrArray3);
    
    // 测试指针数组的索引访问
    std::println("指针数组索引访问:");
    
    // 模拟 ptrArray[i] 的访问
    ptr0 : *int = ptrArray1;  // ptrArray[0]
    ptr1 : *int = ptrArray2;  // ptrArray[1]
    ptr2 : *int = ptrArray3;  // ptrArray[2]
    
    value0 : int = *ptr0;     // *ptrArray[0]
    value1 : int = *ptr1;     // *ptrArray[1]
    value2 : int = *ptr2;     // *ptrArray[2]
    
    std::println("  *ptrArray[0] = " + value0);
    std::println("  *ptrArray[1] = " + value1);
    std::println("  *ptrArray[2] = " + value2);
    
    // 验证指针数组索引访问的正确性
    if (value0 == 111 && value1 == 222 && value2 == 333) {
        std::println("✓ 指针数组索引访问正确");
    } else {
        std::println("✗ 指针数组索引访问错误");
    };
    
    std::println("");
};

fn testMixedOperationsAndBounds() : void {
    std::println("5. 混合操作和边界检查测试");
    std::println("===========================");
    
    // 创建测试数据
    mixedData1 : int = 1001;
    mixedData2 : int = 1002;
    mixedData3 : int = 1003;
    
    // 创建各种类型的指针
    simplePtr : *int = &mixedData1;
    arrayPtr : *int = &mixedData1;  // 模拟数组指针
    
    std::println("混合操作测试:");
    std::println("  简单指针: " + simplePtr + " -> " + *simplePtr);
    std::println("  数组指针: " + arrayPtr + " -> " + *arrayPtr);
    
    // 测试复杂的指针运算
    std::println("复杂指针运算:");
    
    // 指针算术链
    step1 : *int = arrayPtr + 1;
    step2 : *int = step1 + 1;
    step3 : *int = step2 - 1;
    step4 : *int = step3 - 1;
    
    std::println("  arrayPtr + 1: " + step1);
    std::println("  (arrayPtr + 1) + 1: " + step2);
    std::println("  ((arrayPtr + 1) + 1) - 1: " + step3);
    std::println("  (((arrayPtr + 1) + 1) - 1) - 1: " + step4);
    
    // 验证往返一致性
    if (arrayPtr.toString() == step4.toString()) {
        std::println("✓ 复杂指针运算往返一致");
    } else {
        std::println("⚠ 复杂指针运算往返不一致");
    };
    
    // 测试边界安全
    std::println("边界安全测试:");
    testPointerBounds(arrayPtr);
    
    std::println("✓ 混合操作和边界检查测试通过");
    std::println("");
};

// 辅助函数：处理指针数组元素
fn processPointerArrayElement(ptr : *int, index : int) : void {
    std::println("  [" + index + "] " + ptr + " -> " + *ptr);
};

// 辅助函数：安全的数组访问
fn safeArrayAccess(arrayPtr : *int, index : int, size : int) : void {
    if (index >= 0 && index < size) {
        elementPtr : *int = arrayPtr + index;
        std::println("  安全访问 [" + index + "]: " + elementPtr);
    } else {
        std::println("  索引 [" + index + "] 超出边界 [0, " + (size - 1) + "]");
    };
};

// 辅助函数：测试指针边界
fn testPointerBounds(ptr : *int) : void {
    std::println("  基础指针: " + ptr);
    
    // 测试小偏移量
    smallOffset : *int = ptr + 1;
    std::println("  小偏移 (+1): " + smallOffset);
    
    // 测试大偏移量
    largeOffset : *int = ptr + 100;
    std::println("  大偏移 (+100): " + largeOffset);
    
    // 测试负偏移量
    if (ptr.getAddress() > 1000) {  // 确保不会下溢
        negativeOffset : *int = ptr - 1;
        std::println("  负偏移 (-1): " + negativeOffset);
    };
};

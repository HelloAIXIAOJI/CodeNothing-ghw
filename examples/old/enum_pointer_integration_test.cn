using lib <io>;
using ns std;

// 枚举与指针集成测试：展示两大特性的协同使用

// 定义用户状态枚举
enum UserStatus {
    Guest,
    Member(string, int),
    Admin(string, int, string)
};

// 定义操作结果枚举
enum OperationResult {
    Success(string),
    Error(string, int),
    Warning(string)
};

fn main() : int {
    std::println("=== CodeNothing 枚举与指针集成测试 ===");
    
    // 测试1：指向枚举的指针
    testEnumPointers();
    
    // 测试2：枚举中的指针数据
    testPointersInEnums();
    
    // 测试3：函数中的枚举指针
    testEnumPointersInFunctions();
    
    // 测试4：复杂的数据结构
    testComplexDataStructures();
    
    std::println("");
    std::println("=== 枚举与指针集成测试完成 ===");
    return 0;
};

fn testEnumPointers() : void {
    std::println("");
    std::println("1. 指向枚举的指针测试");
    std::println("=====================");
    
    // 创建不同的用户状态
    guest : UserStatus = UserStatus::Guest;
    member : UserStatus = UserStatus::Member("张三", 1001);
    admin : UserStatus = UserStatus::Admin("李四", 2001, "系统管理员");
    
    // 创建指向枚举的指针
    guestPtr : *UserStatus = &guest;
    memberPtr : *UserStatus = &member;
    adminPtr : *UserStatus = &admin;
    
    std::println("用户状态指针:");
    std::println("  访客指针: " + guestPtr);
    std::println("  会员指针: " + memberPtr);
    std::println("  管理员指针: " + adminPtr);
    
    // 通过指针访问枚举值
    derefGuest : UserStatus = *guestPtr;
    derefMember : UserStatus = *memberPtr;
    derefAdmin : UserStatus = *adminPtr;
    
    std::println("解引用后的枚举值:");
    std::println("  " + derefGuest);
    std::println("  " + derefMember);
    std::println("  " + derefAdmin);
    
    // 通过指针调用枚举方法
    processUserStatus(guestPtr);
    processUserStatus(memberPtr);
    processUserStatus(adminPtr);
};

fn processUserStatus(statusPtr : *UserStatus) : void {
    status : UserStatus = *statusPtr;
    statusName : string = status.getVariantName();
    enumName : string = status.getEnumName();
    fieldCount : int = status.length();
    
    std::println("处理用户状态:");
    std::println("  指针: " + statusPtr);
    std::println("  类型: " + enumName);
    std::println("  变体: " + statusName);
    std::println("  字段数: " + fieldCount);
};

fn testPointersInEnums() : void {
    std::println("");
    std::println("2. 枚举中的指针数据测试");
    std::println("=======================");
    
    // 创建一些基础数据
    userName : string = "王五";
    userId : int = 3001;
    userRole : string = "高级管理员";
    
    // 创建指向这些数据的指针
    namePtr : *string = &userName;
    idPtr : *int = &userId;
    rolePtr : *string = &userRole;
    
    std::println("基础数据指针:");
    std::println("  姓名指针: " + namePtr + " -> " + *namePtr);
    std::println("  ID指针: " + idPtr + " -> " + *idPtr);
    std::println("  角色指针: " + rolePtr + " -> " + *rolePtr);
    
    // 使用解引用的值创建枚举
    adminUser : UserStatus = UserStatus::Admin(*namePtr, *idPtr, *rolePtr);
    std::println("创建的管理员用户: " + adminUser);
    
    // 验证数据一致性
    adminName : string = adminUser.getVariantName();
    std::println("管理员用户类型: " + adminName);
};

fn testEnumPointersInFunctions() : void {
    std::println("");
    std::println("3. 函数中的枚举指针测试");
    std::println("=======================");
    
    // 创建操作结果
    successResult : OperationResult = OperationResult::Success("用户创建成功");
    errorResult : OperationResult = OperationResult::Error("数据库连接失败", 500);
    warningResult : OperationResult = OperationResult::Warning("磁盘空间不足");
    
    // 通过指针传递给函数处理
    handleOperationResult(&successResult);
    handleOperationResult(&errorResult);
    handleOperationResult(&warningResult);
    
    // 函数返回枚举指针
    newResult : *OperationResult = createOperationResult(true);
    std::println("函数返回的结果指针: " + newResult);
    std::println("解引用结果: " + *newResult);
};

fn handleOperationResult(resultPtr : *OperationResult) : void {
    result : OperationResult = *resultPtr;
    resultType : string = result.getVariantName();
    
    std::println("处理操作结果:");
    std::println("  指针: " + resultPtr);
    std::println("  类型: " + resultType);
    std::println("  详情: " + result);
    
    // 根据结果类型进行不同处理
    resultStr : string = result.toString();
    if (resultStr.startsWith("OperationResult::Success")) {
        std::println("  ✓ 操作成功");
    } else if (resultStr.startsWith("OperationResult::Error")) {
        std::println("  ✗ 操作失败");
    } else if (resultStr.startsWith("OperationResult::Warning")) {
        std::println("  ⚠ 操作警告");
    };
};

fn createOperationResult(isSuccess : bool) : *OperationResult {
    if (isSuccess) {
        result : OperationResult = OperationResult::Success("操作完成");
        return &result;
    } else {
        result : OperationResult = OperationResult::Error("操作失败", 400);
        return &result;
    };
};

fn testComplexDataStructures() : void {
    std::println("");
    std::println("4. 复杂数据结构测试");
    std::println("===================");
    
    // 创建复杂的用户数据
    superAdmin : UserStatus = UserStatus::Admin("超级管理员", 9999, "系统架构师");
    regularMember : UserStatus = UserStatus::Member("普通用户", 1234);
    
    // 创建指针数组（模拟）
    superAdminPtr : *UserStatus = &superAdmin;
    regularMemberPtr : *UserStatus = &regularMember;
    
    std::println("复杂数据结构:");
    std::println("  超级管理员: " + superAdminPtr + " -> " + *superAdminPtr);
    std::println("  普通用户: " + regularMemberPtr + " -> " + *regularMemberPtr);
    
    // 批量处理用户
    processUserBatch(superAdminPtr);
    processUserBatch(regularMemberPtr);
    
    // 创建操作结果汇总
    batchResult : OperationResult = OperationResult::Success("批量处理完成");
    batchResultPtr : *OperationResult = &batchResult;
    
    std::println("批量处理结果: " + batchResultPtr + " -> " + *batchResultPtr);
};

fn processUserBatch(userPtr : *UserStatus) : void {
    user : UserStatus = *userPtr;
    userType : string = user.getVariantName();
    fieldCount : int = user.length();
    
    std::println("批量处理用户:");
    std::println("  用户指针: " + userPtr);
    std::println("  用户类型: " + userType);
    std::println("  字段数量: " + fieldCount);
    std::println("  处理状态: 完成");
};

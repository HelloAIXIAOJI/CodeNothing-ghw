using lib <io>;
using ns std;

// CodeNothing v0.5.3 函数指针和Lambda函数综合测试

// 基础数学函数
fn add(a : int, b : int) : int {
    return a + b;
};

fn multiply(a : int, b : int) : int {
    return a * b;
};

// 复杂函数（带局部变量和条件语句）
fn complexMath(x : int, y : int) : int {
    temp : int = x * 2;
    if (temp > y) {
        result : int = temp + y;
        return result;
    } else {
        return x + y * 2;
    };
};

// 递归函数
fn fibonacci(n : int) : int {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    };
};

// 字符串处理函数
fn formatMessage(msg : string) : string {
    return "[INFO] " + msg;
};

fn main() : int {
    std::println("=== CodeNothing v0.5.3 函数指针和Lambda综合测试 ===");
    std::println("");
    
    // 测试1：基础函数指针功能
    testBasicFunctionPointers();
    
    // 测试2：Lambda函数功能
    testLambdaFunctions();
    
    // 测试3：复杂函数指针调用
    testComplexFunctionPointers();
    
    // 测试4：递归函数指针
    testRecursiveFunctionPointers();
    
    // 测试5：高阶函数
    testHigherOrderFunctions();
    
    // 测试6：函数指针作为返回值
    testFunctionPointerAsReturnValue();
    
    // 测试7：混合使用函数指针和Lambda
    testMixedFunctionPointersAndLambdas();
    
    std::println("");
    std::println("=== 🎉 所有测试完成！函数指针和Lambda功能完全实现！ ===");
    return 0;
};

fn testBasicFunctionPointers() : void {
    std::println("1. 基础函数指针功能测试");
    std::println("=======================");
    
    // 函数指针声明、赋值和调用
    mathFunc : *fn(int, int) : int = add;
    result1 : int = mathFunc(10, 5);
    std::println("mathFunc(10, 5) = " + result1);
    
    // 重新赋值
    mathFunc = multiply;
    result2 : int = mathFunc(10, 5);
    std::println("mathFunc(10, 5) = " + result2);
    
    // 函数指针方法
    std::println("函数指针信息: " + mathFunc.toString());
    std::println("函数名: " + mathFunc.getName());
    std::println("参数数量: " + mathFunc.getParamCount());
    
    std::println("");
};

fn testLambdaFunctions() : void {
    std::println("2. Lambda函数功能测试");
    std::println("=====================");
    
    // 简单Lambda
    square : *fn(int) : int = (x => x * x);
    result1 : int = square(7);
    std::println("square(7) = " + result1);
    
    // 多参数Lambda
    power : *fn(int, int) : int = ((base, exp) => base * base * exp);
    result2 : int = power(3, 2);
    std::println("power(3, 2) = " + result2);
    
    // Lambda方法调用
    std::println("Lambda信息: " + square.toString());
    std::println("是否为Lambda: " + square.isLambda());
    
    std::println("");
};

fn testComplexFunctionPointers() : void {
    std::println("3. 复杂函数指针调用测试");
    std::println("=======================");
    
    // 复杂函数的函数指针
    complexFunc : *fn(int, int) : int = complexMath;
    
    result1 : int = complexFunc(5, 8);
    std::println("complexFunc(5, 8) = " + result1);
    
    result2 : int = complexFunc(2, 15);
    std::println("complexFunc(2, 15) = " + result2);
    
    std::println("");
};

fn testRecursiveFunctionPointers() : void {
    std::println("4. 递归函数指针测试");
    std::println("===================");
    
    // 递归函数的函数指针
    fibFunc : *fn(int) : int = fibonacci;
    
    result1 : int = fibFunc(6);
    std::println("fibFunc(6) = " + result1);
    
    result2 : int = fibFunc(8);
    std::println("fibFunc(8) = " + result2);
    
    std::println("");
};

fn testHigherOrderFunctions() : void {
    std::println("5. 高阶函数测试");
    std::println("===============");
    
    // 使用函数指针作为参数
    result1 : int = applyBinaryOp(12, 8, add);
    std::println("applyBinaryOp(12, 8, add) = " + result1);
    
    result2 : int = applyBinaryOp(12, 8, multiply);
    std::println("applyBinaryOp(12, 8, multiply) = " + result2);
    
    // 使用Lambda作为参数
    result3 : int = applyBinaryOp(12, 8, ((a, b) => a - b));
    std::println("applyBinaryOp(12, 8, subtract_lambda) = " + result3);
    
    std::println("");
};

fn testFunctionPointerAsReturnValue() : void {
    std::println("6. 函数指针作为返回值测试");
    std::println("===========================");
    
    // 获取不同的函数指针
    addPtr : *fn(int, int) : int = getMathOperation("add");
    result1 : int = addPtr(15, 7);
    std::println("getMathOperation(\"add\")(15, 7) = " + result1);
    
    mulPtr : *fn(int, int) : int = getMathOperation("multiply");
    result2 : int = mulPtr(15, 7);
    std::println("getMathOperation(\"multiply\")(15, 7) = " + result2);
    
    std::println("");
};

fn testMixedFunctionPointersAndLambdas() : void {
    std::println("7. 混合使用函数指针和Lambda测试");
    std::println("===============================");
    
    // 创建多个不同类型的函数指针
    normalFunc : *fn(int, int) : int = add;
    lambdaFunc : *fn(int, int) : int = ((a, b) => a * a + b * b);
    complexFunc : *fn(int, int) : int = complexMath;
    
    // 依次调用
    result1 : int = normalFunc(4, 3);
    std::println("normalFunc(4, 3) = " + result1);
    
    result2 : int = lambdaFunc(4, 3);
    std::println("lambdaFunc(4, 3) = " + result2);
    
    result3 : int = complexFunc(4, 3);
    std::println("complexFunc(4, 3) = " + result3);
    
    // 比较函数指针
    std::println("函数类型比较:");
    std::println("  normalFunc.isLambda(): " + normalFunc.isLambda());
    std::println("  lambdaFunc.isLambda(): " + lambdaFunc.isLambda());
    std::println("  complexFunc.isLambda(): " + complexFunc.isLambda());
    
    std::println("");
};

// 高阶函数：接受函数指针作为参数
fn applyBinaryOp(a : int, b : int, operation : *fn(int, int) : int) : int {
    return operation(a, b);
};

// 返回函数指针的函数
fn getMathOperation(opName : string) : *fn(int, int) : int {
    if (opName == "add") {
        return add;
    } else if (opName == "multiply") {
        return multiply;
    } else {
        return add; // 默认
    };
};

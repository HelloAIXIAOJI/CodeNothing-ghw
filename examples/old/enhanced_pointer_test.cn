using lib <io>;
using ns std;

// CodeNothing 增强指针功能测试
// 测试v0.5.5中新增的指针安全特性

fn main() : int {
    std::println("=== CodeNothing 增强指针功能测试 ===");
    std::println("");
    
    // 测试1：基础指针安全操作
    testBasicPointerSafety();
    
    // 测试2：指针算术安全检查
    testPointerArithmeticSafety();
    
    // 测试3：指针生命周期管理
    testPointerLifecycleManagement();
    
    // 测试4：指针错误处理
    testPointerErrorHandling();
    
    std::println("");
    std::println("=== 增强指针功能测试完成 ===");
    return 0;
};

fn testBasicPointerSafety() : void {
    std::println("1. 基础指针安全操作测试");
    std::println("========================");
    
    // 创建基础数据
    value1 : int = 100;
    value2 : float = 3.14;
    value3 : string = "Safe Pointer";
    
    // 创建指针
    ptr1 : *int = &value1;
    ptr2 : *float = &value2;
    ptr3 : *string = &value3;
    
    std::println("原始数据:");
    std::println("  value1: " + value1);
    std::println("  value2: " + value2);
    std::println("  value3: " + value3);
    
    std::println("指针信息:");
    std::println("  ptr1: " + ptr1 + " -> " + *ptr1);
    std::println("  ptr2: " + ptr2 + " -> " + *ptr2);
    std::println("  ptr3: " + ptr3 + " -> " + *ptr3);
    
    // 测试指针有效性检查
    std::println("指针有效性检查:");
    std::println("  ptr1.isNull(): " + ptr1.isNull());
    std::println("  ptr2.isNull(): " + ptr2.isNull());
    std::println("  ptr3.isNull(): " + ptr3.isNull());
    
    // 验证指针安全性
    if (*ptr1 == value1 && *ptr2 == value2 && *ptr3 == value3) {
        std::println("✓ 基础指针安全操作正确");
    } else {
        std::println("✗ 基础指针安全操作错误");
    };
    
    std::println("");
};

fn testPointerArithmeticSafety() : void {
    std::println("2. 指针算术安全检查测试");
    std::println("========================");
    
    // 创建测试数据
    baseValue : int = 200;
    basePtr : *int = &baseValue;
    
    std::println("基础指针: " + basePtr + " -> " + *baseValue);
    
    // 测试安全的指针算术
    std::println("安全指针算术测试:");
    
    // 小偏移量（应该安全）
    ptr1 : *int = basePtr + 1;
    ptr2 : *int = basePtr + 2;
    ptr3 : *int = basePtr + 3;
    
    std::println("  basePtr + 1: " + ptr1);
    std::println("  basePtr + 2: " + ptr2);
    std::println("  basePtr + 3: " + ptr3);
    
    // 反向算术
    backPtr1 : *int = ptr3 - 1;
    backPtr2 : *int = backPtr1 - 1;
    backPtr3 : *int = backPtr2 - 1;
    
    std::println("  (basePtr + 3) - 1: " + backPtr1);
    std::println("  ((basePtr + 3) - 1) - 1: " + backPtr2);
    std::println("  (((basePtr + 3) - 1) - 1) - 1: " + backPtr3);
    
    // 验证往返一致性
    if (basePtr.toString() == backPtr3.toString()) {
        std::println("✓ 指针算术往返一致");
    } else {
        std::println("⚠ 指针算术往返不一致");
    };
    
    // 测试指针差值计算
    diff1 : int = ptr2 - basePtr;
    diff2 : int = ptr3 - ptr1;
    
    std::println("指针差值计算:");
    std::println("  (basePtr + 2) - basePtr = " + diff1);
    std::println("  (basePtr + 3) - (basePtr + 1) = " + diff2);
    
    if (diff1 == 2 && diff2 == 2) {
        std::println("✓ 指针差值计算正确");
    } else {
        std::println("✗ 指针差值计算错误");
    };
    
    std::println("");
};

fn testPointerLifecycleManagement() : void {
    std::println("3. 指针生命周期管理测试");
    std::println("========================");
    
    // 创建局部变量和指针
    localValue : int = 300;
    localPtr : *int = &localValue;
    
    std::println("局部变量指针:");
    std::println("  localValue: " + localValue);
    std::println("  localPtr: " + localPtr + " -> " + *localPtr);
    
    // 测试指针复制
    copiedPtr1 : *int = localPtr;
    copiedPtr2 : *int = localPtr;
    
    std::println("指针复制:");
    std::println("  copiedPtr1: " + copiedPtr1 + " -> " + *copiedPtr1);
    std::println("  copiedPtr2: " + copiedPtr2 + " -> " + *copiedPtr2);
    
    // 验证所有指针指向同一位置
    if (localPtr.toString() == copiedPtr1.toString() && 
        copiedPtr1.toString() == copiedPtr2.toString()) {
        std::println("✓ 指针复制正确");
    } else {
        std::println("✗ 指针复制错误");
    };
    
    // 测试指针作为函数参数
    std::println("指针作为函数参数:");
    processPointerSafely(localPtr);
    
    // 验证原始值未被意外修改
    if (*localPtr == localValue) {
        std::println("✓ 指针参数传递安全");
    } else {
        std::println("✗ 指针参数传递不安全");
    };
    
    std::println("");
};

fn testPointerErrorHandling() : void {
    std::println("4. 指针错误处理测试");
    std::println("===================");
    
    // 创建有效指针
    validValue : int = 400;
    validPtr : *int = &validValue;
    
    std::println("有效指针测试:");
    std::println("  validPtr: " + validPtr + " -> " + *validPtr);
    std::println("  validPtr.isNull(): " + validPtr.isNull());
    
    // 测试指针的内置方法
    std::println("指针内置方法:");
    std::println("  getAddress(): " + validPtr.getAddress());
    std::println("  getLevel(): " + validPtr.getLevel());
    std::println("  toString(): " + validPtr.toString());
    
    // 测试边界情况
    std::println("边界情况测试:");
    
    // 大偏移量（可能触发安全检查）
    largeOffsetPtr : *int = validPtr + 1000;
    std::println("  大偏移指针: " + largeOffsetPtr);
    
    // 非常大的偏移量
    veryLargeOffsetPtr : *int = validPtr + 100000;
    std::println("  超大偏移指针: " + veryLargeOffsetPtr);
    
    // 负偏移量（如果地址足够大）
    if (validPtr.getAddress() > 10000) {
        negativeOffsetPtr : *int = validPtr - 1;
        std::println("  负偏移指针: " + negativeOffsetPtr);
    };
    
    std::println("✓ 指针错误处理测试完成");
    std::println("");
};

// 辅助函数：安全处理指针
fn processPointerSafely(ptr : *int) : void {
    std::println("  处理指针: " + ptr + " -> " + *ptr);
    
    // 验证指针有效性
    if (!ptr.isNull()) {
        value : int = *ptr;
        std::println("  安全访问值: " + value);
    } else {
        std::println("  指针为空，跳过访问");
    };
};

// 辅助函数：指针比较
fn comparePointers(ptr1 : *int, ptr2 : *int) : bool {
    return ptr1.toString() == ptr2.toString();
};

// 辅助函数：安全的指针操作
fn safePointerOperation(ptr : *int) : int {
    if (!ptr.isNull()) {
        return *ptr;
    } else {
        return -1;  // 错误值
    };
};

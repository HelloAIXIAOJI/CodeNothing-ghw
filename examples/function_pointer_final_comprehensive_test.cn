using lib <io>;
using ns std;

// CodeNothing v0.5.3 å‡½æ•°æŒ‡é’ˆå’ŒLambdaå‡½æ•°ç»¼åˆæµ‹è¯•

// åŸºç¡€æ•°å­¦å‡½æ•°
fn add(a : int, b : int) : int {
    return a + b;
};

fn multiply(a : int, b : int) : int {
    return a * b;
};

// å¤æ‚å‡½æ•°ï¼ˆå¸¦å±€éƒ¨å˜é‡å’Œæ¡ä»¶è¯­å¥ï¼‰
fn complexMath(x : int, y : int) : int {
    temp : int = x * 2;
    if (temp > y) {
        result : int = temp + y;
        return result;
    } else {
        return x + y * 2;
    };
};

// é€’å½’å‡½æ•°
fn fibonacci(n : int) : int {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    };
};

// å­—ç¬¦ä¸²å¤„ç†å‡½æ•°
fn formatMessage(msg : string) : string {
    return "[INFO] " + msg;
};

fn main() : int {
    std::println("=== CodeNothing v0.5.3 å‡½æ•°æŒ‡é’ˆå’ŒLambdaç»¼åˆæµ‹è¯• ===");
    std::println("");
    
    // æµ‹è¯•1ï¼šåŸºç¡€å‡½æ•°æŒ‡é’ˆåŠŸèƒ½
    testBasicFunctionPointers();
    
    // æµ‹è¯•2ï¼šLambdaå‡½æ•°åŠŸèƒ½
    testLambdaFunctions();
    
    // æµ‹è¯•3ï¼šå¤æ‚å‡½æ•°æŒ‡é’ˆè°ƒç”¨
    testComplexFunctionPointers();
    
    // æµ‹è¯•4ï¼šé€’å½’å‡½æ•°æŒ‡é’ˆ
    testRecursiveFunctionPointers();
    
    // æµ‹è¯•5ï¼šé«˜é˜¶å‡½æ•°
    testHigherOrderFunctions();
    
    // æµ‹è¯•6ï¼šå‡½æ•°æŒ‡é’ˆä½œä¸ºè¿”å›å€¼
    testFunctionPointerAsReturnValue();
    
    // æµ‹è¯•7ï¼šæ··åˆä½¿ç”¨å‡½æ•°æŒ‡é’ˆå’ŒLambda
    testMixedFunctionPointersAndLambdas();
    
    std::println("");
    std::println("=== ğŸ‰ æ‰€æœ‰æµ‹è¯•å®Œæˆï¼å‡½æ•°æŒ‡é’ˆå’ŒLambdaåŠŸèƒ½å®Œå…¨å®ç°ï¼ ===");
    return 0;
};

fn testBasicFunctionPointers() : void {
    std::println("1. åŸºç¡€å‡½æ•°æŒ‡é’ˆåŠŸèƒ½æµ‹è¯•");
    std::println("=======================");
    
    // å‡½æ•°æŒ‡é’ˆå£°æ˜ã€èµ‹å€¼å’Œè°ƒç”¨
    mathFunc : *fn(int, int) : int = add;
    result1 : int = mathFunc(10, 5);
    std::println("mathFunc(10, 5) = " + result1);
    
    // é‡æ–°èµ‹å€¼
    mathFunc = multiply;
    result2 : int = mathFunc(10, 5);
    std::println("mathFunc(10, 5) = " + result2);
    
    // å‡½æ•°æŒ‡é’ˆæ–¹æ³•
    std::println("å‡½æ•°æŒ‡é’ˆä¿¡æ¯: " + mathFunc.toString());
    std::println("å‡½æ•°å: " + mathFunc.getName());
    std::println("å‚æ•°æ•°é‡: " + mathFunc.getParamCount());
    
    std::println("");
};

fn testLambdaFunctions() : void {
    std::println("2. Lambdaå‡½æ•°åŠŸèƒ½æµ‹è¯•");
    std::println("=====================");
    
    // ç®€å•Lambda
    square : *fn(int) : int = (x => x * x);
    result1 : int = square(7);
    std::println("square(7) = " + result1);
    
    // å¤šå‚æ•°Lambda
    power : *fn(int, int) : int = ((base, exp) => base * base * exp);
    result2 : int = power(3, 2);
    std::println("power(3, 2) = " + result2);
    
    // Lambdaæ–¹æ³•è°ƒç”¨
    std::println("Lambdaä¿¡æ¯: " + square.toString());
    std::println("æ˜¯å¦ä¸ºLambda: " + square.isLambda());
    
    std::println("");
};

fn testComplexFunctionPointers() : void {
    std::println("3. å¤æ‚å‡½æ•°æŒ‡é’ˆè°ƒç”¨æµ‹è¯•");
    std::println("=======================");
    
    // å¤æ‚å‡½æ•°çš„å‡½æ•°æŒ‡é’ˆ
    complexFunc : *fn(int, int) : int = complexMath;
    
    result1 : int = complexFunc(5, 8);
    std::println("complexFunc(5, 8) = " + result1);
    
    result2 : int = complexFunc(2, 15);
    std::println("complexFunc(2, 15) = " + result2);
    
    std::println("");
};

fn testRecursiveFunctionPointers() : void {
    std::println("4. é€’å½’å‡½æ•°æŒ‡é’ˆæµ‹è¯•");
    std::println("===================");
    
    // é€’å½’å‡½æ•°çš„å‡½æ•°æŒ‡é’ˆ
    fibFunc : *fn(int) : int = fibonacci;
    
    result1 : int = fibFunc(6);
    std::println("fibFunc(6) = " + result1);
    
    result2 : int = fibFunc(8);
    std::println("fibFunc(8) = " + result2);
    
    std::println("");
};

fn testHigherOrderFunctions() : void {
    std::println("5. é«˜é˜¶å‡½æ•°æµ‹è¯•");
    std::println("===============");
    
    // ä½¿ç”¨å‡½æ•°æŒ‡é’ˆä½œä¸ºå‚æ•°
    result1 : int = applyBinaryOp(12, 8, add);
    std::println("applyBinaryOp(12, 8, add) = " + result1);
    
    result2 : int = applyBinaryOp(12, 8, multiply);
    std::println("applyBinaryOp(12, 8, multiply) = " + result2);
    
    // ä½¿ç”¨Lambdaä½œä¸ºå‚æ•°
    result3 : int = applyBinaryOp(12, 8, ((a, b) => a - b));
    std::println("applyBinaryOp(12, 8, subtract_lambda) = " + result3);
    
    std::println("");
};

fn testFunctionPointerAsReturnValue() : void {
    std::println("6. å‡½æ•°æŒ‡é’ˆä½œä¸ºè¿”å›å€¼æµ‹è¯•");
    std::println("===========================");
    
    // è·å–ä¸åŒçš„å‡½æ•°æŒ‡é’ˆ
    addPtr : *fn(int, int) : int = getMathOperation("add");
    result1 : int = addPtr(15, 7);
    std::println("getMathOperation(\"add\")(15, 7) = " + result1);
    
    mulPtr : *fn(int, int) : int = getMathOperation("multiply");
    result2 : int = mulPtr(15, 7);
    std::println("getMathOperation(\"multiply\")(15, 7) = " + result2);
    
    std::println("");
};

fn testMixedFunctionPointersAndLambdas() : void {
    std::println("7. æ··åˆä½¿ç”¨å‡½æ•°æŒ‡é’ˆå’ŒLambdaæµ‹è¯•");
    std::println("===============================");
    
    // åˆ›å»ºå¤šä¸ªä¸åŒç±»å‹çš„å‡½æ•°æŒ‡é’ˆ
    normalFunc : *fn(int, int) : int = add;
    lambdaFunc : *fn(int, int) : int = ((a, b) => a * a + b * b);
    complexFunc : *fn(int, int) : int = complexMath;
    
    // ä¾æ¬¡è°ƒç”¨
    result1 : int = normalFunc(4, 3);
    std::println("normalFunc(4, 3) = " + result1);
    
    result2 : int = lambdaFunc(4, 3);
    std::println("lambdaFunc(4, 3) = " + result2);
    
    result3 : int = complexFunc(4, 3);
    std::println("complexFunc(4, 3) = " + result3);
    
    // æ¯”è¾ƒå‡½æ•°æŒ‡é’ˆ
    std::println("å‡½æ•°ç±»å‹æ¯”è¾ƒ:");
    std::println("  normalFunc.isLambda(): " + normalFunc.isLambda());
    std::println("  lambdaFunc.isLambda(): " + lambdaFunc.isLambda());
    std::println("  complexFunc.isLambda(): " + complexFunc.isLambda());
    
    std::println("");
};

// é«˜é˜¶å‡½æ•°ï¼šæ¥å—å‡½æ•°æŒ‡é’ˆä½œä¸ºå‚æ•°
fn applyBinaryOp(a : int, b : int, operation : *fn(int, int) : int) : int {
    return operation(a, b);
};

// è¿”å›å‡½æ•°æŒ‡é’ˆçš„å‡½æ•°
fn getMathOperation(opName : string) : *fn(int, int) : int {
    if (opName == "add") {
        return add;
    } else if (opName == "multiply") {
        return multiply;
    } else {
        return add; // é»˜è®¤
    };
};

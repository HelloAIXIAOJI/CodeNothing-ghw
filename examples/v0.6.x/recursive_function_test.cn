// 🚀 CodeNothing v0.6.7 递归函数优化专项测试
// 验证递归函数的JIT编译优化效果

using lib <io>;
using ns std;

// 简单递归函数
fn factorial(n : int) : int {
    if (n <= 1) {
        return 1;
    };
    return n * factorial(n - 1);
};

fn fibonacci(n : int) : int {
    if (n <= 1) {
        return n;
    };
    return fibonacci(n - 1) + fibonacci(n - 2);
};

// 尾递归函数
fn factorial_tail(n : int, acc : int) : int {
    if (n <= 1) {
        return acc;
    };
    return factorial_tail(n - 1, acc * n);
};

fn sum_tail(n : int, acc : int) : int {
    if (n <= 0) {
        return acc;
    };
    return sum_tail(n - 1, acc + n);
};

// 线性递归函数
fn power(base : int, exp : int) : int {
    if (exp == 0) {
        return 1;
    };
    if (exp == 1) {
        return base;
    };
    return base * power(base, exp - 1);
};

fn gcd(a : int, b : int) : int {
    if (b == 0) {
        return a;
    };
    return gcd(b, a % b);
};

fn main() : int {
    std::println("🚀 CodeNothing v0.6.7 递归函数优化专项测试");
    std::println("=====================================");
    std::println("目标：验证递归函数JIT编译优化");
    std::println("=====================================");
    
    // 📊 测试1：简单递归函数测试
    std::println("🔄 测试1：简单递归函数测试");
    simple_recursive_result : int = 0;
    for (i : 1..21) {  // 20次迭代，触发递归函数热点检测
        if (i <= 10) {
            simple_recursive_result = simple_recursive_result + factorial(i);
        };
        if (i <= 15) {
            simple_recursive_result = simple_recursive_result + fibonacci(i);
        };
    };
    std::println("简单递归结果: " + simple_recursive_result);
    std::println("-------------------------------------");
    
    // 📊 测试2：尾递归优化测试
    std::println("🎯 测试2：尾递归优化测试");
    tail_recursive_result : int = 0;
    for (i : 1..21) {  // 20次迭代
        if (i <= 10) {
            tail_recursive_result = tail_recursive_result + factorial_tail(i, 1);
        };
        if (i <= 15) {
            tail_recursive_result = tail_recursive_result + sum_tail(i, 0);
        };
    };
    std::println("尾递归结果: " + tail_recursive_result);
    std::println("-------------------------------------");
    
    // 📊 测试3：线性递归函数测试
    std::println("📈 测试3：线性递归函数测试");
    linear_recursive_result : int = 0;
    for (i : 1..21) {  // 20次迭代
        if (i <= 8) {
            linear_recursive_result = linear_recursive_result + power(2, i);
        };
        if (i <= 15) {
            j : int = i + 10;
            linear_recursive_result = linear_recursive_result + gcd(i, j);
        };
    };
    std::println("线性递归结果: " + linear_recursive_result);
    std::println("-------------------------------------");
    
    // 📊 测试4：递归深度控制测试
    std::println("🛡️ 测试4：递归深度控制测试");
    depth_control_result : int = 0;
    for (i : 1..11) {  // 10次迭代，控制递归深度
        // 小深度递归
        if (i <= 5) {
            depth_control_result = depth_control_result + factorial(i);
        };
        // 中等深度递归
        if (i <= 8) {
            depth_control_result = depth_control_result + fibonacci(i);
        };
        // 线性递归
        depth_control_result = depth_control_result + power(2, i);
    };
    std::println("深度控制结果: " + depth_control_result);
    std::println("-------------------------------------");
    
    // 📊 测试5：递归函数组合测试
    std::println("🎨 测试5：递归函数组合测试");
    combination_result : int = 0;
    for (i : 1..16) {  // 15次迭代
        // 组合不同类型的递归函数
        fact_val : int = factorial(i % 6 + 1);
        fib_val : int = fibonacci(i % 8 + 1);
        pow_val : int = power(2, i % 5 + 1);
        combination_result = combination_result + fact_val + fib_val + pow_val;
    };
    std::println("递归组合结果: " + combination_result);
    std::println("-------------------------------------");
    
    // 📊 测试6：递归函数性能基准测试
    std::println("⚡ 测试6：递归函数性能基准测试");
    performance_result : int = 0;
    for (i : 1..51) {  // 50次迭代，高强度测试
        // 高频递归调用
        if (i % 2 == 0) {
            performance_result = performance_result + factorial(i % 7 + 1);
        };
        if (i % 3 == 0) {
            performance_result = performance_result + fibonacci(i % 6 + 1);
        };
        if (i % 5 == 0) {
            performance_result = performance_result + power(2, i % 4 + 1);
        };
        performance_result = performance_result + gcd(i, i + 5);
    };
    std::println("性能基准结果: " + performance_result);
    std::println("-------------------------------------");
    
    // 📊 测试7：递归优化策略验证测试
    std::println("🔧 测试7：递归优化策略验证测试");
    optimization_result : int = 0;
    for (i : 1..31) {  // 30次迭代
        // 验证不同优化策略
        // 尾递归优化
        tail_result : int = factorial_tail(i % 5 + 1, 1);
        // 线性递归优化
        linear_result : int = power(2, i % 4 + 1);
        // 简单递归
        simple_result : int = factorial(i % 4 + 1);
        
        optimization_result = optimization_result + tail_result + linear_result + simple_result;
    };
    std::println("优化策略结果: " + optimization_result);
    std::println("=====================================");
    
    // 计算总体性能指标
    total_operations : int = simple_recursive_result + tail_recursive_result + linear_recursive_result + depth_control_result + combination_result + performance_result + optimization_result;
    std::println("📈 递归优化统计总结:");
    std::println("总操作数: " + total_operations);
    std::println("总迭代次数: 180+");
    std::println("递归函数调用次数: 1000+");
    std::println("=====================================");
    
    std::println("🎉 递归函数优化测试完成！");
    std::println("请查看JIT统计信息验证递归优化效果");
    
    return 0;
};

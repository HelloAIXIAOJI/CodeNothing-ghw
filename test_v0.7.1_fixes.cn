// 测试v0.7.1修复：Auto类型推断和访问修饰符
using lib <io>;
using ns std;

// 测试访问修饰符的类
class AccessTest {
    private secret : int;
    protected internal : int;
    public visible : int;
    
    constructor(value : int) {
        this.secret = value;
        this.internal = value * 2;
        this.visible = value * 3;
    };
    
    private fn getSecret() : int {
        return this.secret;
    };
    
    protected fn getInternal() : int {
        return this.internal;
    };
    
    public fn getVisible() : int {
        return this.visible;
    };
    
    public fn testInternalAccess() : void {
        // 内部访问私有成员应该成功
        std::println("内部访问私有字段: " + this.secret);
        std::println("内部调用私有方法: " + this.getSecret());
    };
    
    public fn testAutoTypeInference() : void {
        // 测试Auto类型推断
        std::println("=== Auto类型推断测试 ===");
        
        // Auto + Auto 应该推断为 int
        auto_a : Auto = 10;
        auto_b : Auto = 20;
        auto_sum : Auto = auto_a + auto_b;
        std::println("Auto + Auto = " + auto_sum);

        // Auto + int 应该推断为 int
        auto_c : Auto = 5;
        int_d : int = 15;
        mixed_sum : Auto = auto_c + int_d;
        std::println("Auto + int = " + mixed_sum);

        // Auto + float 应该推断为 float
        auto_e : Auto = 3;
        float_f : float = 2.5;
        float_sum : Auto = auto_e + float_f;
        std::println("Auto + float = " + float_sum);

        // Auto + string 应该推断为 string
        auto_g : Auto = "Hello ";
        string_h : string = "World!";
        string_concat : Auto = auto_g + string_h;
        std::println("Auto + string = " + string_concat);
    };
};

// 简化版测试类（不使用继承）
class SimpleTest {
    public value : int;

    constructor(val : int) {
        this.value = val;
    };

    public fn getValue() : int {
        return this.value;
    };
};

fn main() : int {
    std::println("测试v0.7.1修复：Auto类型推断和访问修饰符");
    std::println("");
    
    // 测试1: Auto类型推断
    std::println("=== 测试1: Auto类型推断 ===");
    test_obj : AccessTest = new AccessTest(42);
    test_obj.testAutoTypeInference();
    std::println("");
    
    // 测试2: 访问修饰符 - 内部访问
    std::println("=== 测试2: 内部访问（应该成功） ===");
    test_obj.testInternalAccess();
    std::println("");
    
    // 测试3: 访问修饰符 - 外部访问public
    std::println("=== 测试3: 外部访问public（应该成功） ===");
    std::println("外部访问public字段: " + test_obj.visible);
    std::println("外部调用public方法: " + test_obj.getVisible());
    std::println("");
    
    // 测试4: 访问修饰符 - 外部访问private（应该失败）
    std::println("=== 测试4: 外部访问private（应该失败） ===");
    // 这些调用应该产生错误信息
    // std::println("尝试外部访问private字段: " + test_obj.secret);
    // std::println("尝试外部调用private方法: " + test_obj.getSecret());
    std::println("（private访问测试已注释，避免运行时错误）");
    std::println("");
    
    // 测试5: 简单类测试
    std::println("=== 测试5: 简单类测试 ===");
    simple_obj : SimpleTest = new SimpleTest(100);
    std::println("简单类值: " + simple_obj.getValue());
    std::println("");
    
    // 测试6: 复杂的Auto类型推断场景
    std::println("=== 测试6: 复杂Auto类型推断 ===");

    // 算术运算链
    a : Auto = 1;
    b : Auto = 2;
    c : Auto = 3;
    result : Auto = a + b * c - 1;
    std::println("复杂算术运算: 1 + 2 * 3 - 1 = " + result);

    // 字符串拼接链
    greeting : Auto = "Hello";
    space : Auto = " ";
    name : Auto = "CodeNothing";
    exclamation : Auto = "!";
    message : Auto = greeting + space + name + exclamation;
    std::println("字符串拼接链: " + message);
    
    std::println("");
    std::println("v0.7.1修复测试完成！");
    return 0;
};
